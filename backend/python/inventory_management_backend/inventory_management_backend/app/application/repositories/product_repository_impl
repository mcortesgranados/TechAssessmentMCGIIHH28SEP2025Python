from app.adapters.db.session import get_db_session
from app.adapters.db.base import Product

class ProductRepositoryImpl:
    """
    Product Repository Implementation - Hexagonal Architecture Adapter
    
    This class implements the Repository pattern as part of a hexagonal (ports & adapters) 
    microservice architecture with event-driven design following SOLID principles.
    
    ARCHITECTURAL PATTERNS:
    ======================
    
    ğŸ—ï¸ Hexagonal Architecture (Ports & Adapters):
        - Acts as a secondary adapter (infrastructure layer)
        - Implements the ProductRepository port defined in the domain layer
        - Provides data persistence abstraction for the Product domain entity
        - Isolates business logic from external dependencies (database)
    
    ğŸ”§ Microservices Pattern:
        - Encapsulates product data operations within bounded context
        - Supports service autonomy and independent deployment
        - Enables horizontal scaling of product-related operations
        - Facilitates technology diversity across service boundaries
    
    ğŸ“¡ Event-Driven Architecture:
        - Publishes domain events when product state changes occur
        - Supports eventual consistency across service boundaries  
        - Enables loose coupling between microservices
        - Facilitates real-time data synchronization and notifications
    
    SOLID PRINCIPLES ADHERENCE:
    ===========================
    
    S - Single Responsibility Principle:
        âœ… Solely responsible for product data persistence operations
        âœ… Separates data access concerns from business logic
    
    O - Open/Closed Principle:
        âœ… Open for extension through interface implementation
        âœ… Closed for modification of core persistence logic
    
    L - Liskov Substitution Principle:
        âœ… Fully substitutable for any ProductRepository implementation
        âœ… Maintains behavioral contracts defined by the repository interface
    
    I - Interface Segregation Principle:
        âœ… Implements specific product repository interface
        âœ… Clients depend only on methods they actually use
    
    D - Dependency Inversion Principle:
        âœ… Depends on database session abstraction, not concrete implementations
        âœ… Supports dependency injection for testing and flexibility
    
    BENEFITS:
    =========
    - ğŸ”„ Testability: Easy to mock and unit test through dependency injection
    - ğŸ›¡ï¸ Maintainability: Clean separation of concerns and responsibilities  
    - ğŸš€ Scalability: Independent scaling of data layer operations
    - ğŸ”Œ Flexibility: Swappable persistence implementations
    - ğŸ¯ Domain Focus: Business logic remains persistence-agnostic
    
    USAGE EXAMPLE:
    ==============
    ```python
    # Dependency injection for testing
    mock_session = Mock()
    repository = ProductRepositoryImpl(session=mock_session)
    
    # Production usage with default session
    repository = ProductRepositoryImpl()
    products = repository.get_all_products()
    ```
    
    ğŸ‘©â€ğŸ’» Author: Manuela CortÃ©s Granados (manuelacortesgranados@gmail.com)
    ğŸ”— https://www.linkedin.com/in/mcortesgranados/
    ğŸ“… Date: 2025-09-28
    """
    def __init__(self, session=None):
        self.session = session or get_db_session()

    def get_all_products(self):
        return self.session.query(Product).all()