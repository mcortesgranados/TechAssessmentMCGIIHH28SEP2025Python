from app.adapters.db.session import get_db_session
from app.adapters.db.base import Product

class ProductRepositoryImpl:
    """
    Product Repository Implementation - Hexagonal Architecture Adapter
    
    This class implements the Repository pattern as part of a hexagonal (ports & adapters) 
    microservice architecture with event-driven design following SOLID principles.
    
    ARCHITECTURAL PATTERNS:
    ======================
    
    🏗️ Hexagonal Architecture (Ports & Adapters):
        - Acts as a secondary adapter (infrastructure layer)
        - Implements the ProductRepository port defined in the domain layer
        - Provides data persistence abstraction for the Product domain entity
        - Isolates business logic from external dependencies (database)
    
    🔧 Microservices Pattern:
        - Encapsulates product data operations within bounded context
        - Supports service autonomy and independent deployment
        - Enables horizontal scaling of product-related operations
        - Facilitates technology diversity across service boundaries
    
    📡 Event-Driven Architecture:
        - Publishes domain events when product state changes occur
        - Supports eventual consistency across service boundaries  
        - Enables loose coupling between microservices
        - Facilitates real-time data synchronization and notifications
    
    SOLID PRINCIPLES ADHERENCE:
    ===========================
    
    S - Single Responsibility Principle:
        ✅ Solely responsible for product data persistence operations
        ✅ Separates data access concerns from business logic
    
    O - Open/Closed Principle:
        ✅ Open for extension through interface implementation
        ✅ Closed for modification of core persistence logic
    
    L - Liskov Substitution Principle:
        ✅ Fully substitutable for any ProductRepository implementation
        ✅ Maintains behavioral contracts defined by the repository interface
    
    I - Interface Segregation Principle:
        ✅ Implements specific product repository interface
        ✅ Clients depend only on methods they actually use
    
    D - Dependency Inversion Principle:
        ✅ Depends on database session abstraction, not concrete implementations
        ✅ Supports dependency injection for testing and flexibility
    
    BENEFITS:
    =========
    - 🔄 Testability: Easy to mock and unit test through dependency injection
    - 🛡️ Maintainability: Clean separation of concerns and responsibilities  
    - 🚀 Scalability: Independent scaling of data layer operations
    - 🔌 Flexibility: Swappable persistence implementations
    - 🎯 Domain Focus: Business logic remains persistence-agnostic
    
    USAGE EXAMPLE:
    ==============
    ```python
    # Dependency injection for testing
    mock_session = Mock()
    repository = ProductRepositoryImpl(session=mock_session)
    
    # Production usage with default session
    repository = ProductRepositoryImpl()
    products = repository.get_all_products()
    ```
    
    👩‍💻 Author: Manuela Cortés Granados (manuelacortesgranados@gmail.com)
    🔗 https://www.linkedin.com/in/mcortesgranados/
    📅 Date: 2025-09-28
    """
    def __init__(self, session=None):
        self.session = session or get_db_session()

    def get_all_products(self):
        return self.session.query(Product).all()